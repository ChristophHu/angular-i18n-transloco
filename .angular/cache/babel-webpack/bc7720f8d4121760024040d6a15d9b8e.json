{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nclass DefaultLoader {\n  constructor(translations) {\n    this.translations = translations;\n  }\n\n  getTranslation(lang) {\n    return of(this.translations.get(lang) || {});\n  }\n\n}\n\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n  if (!obj) {\n    return obj;\n  }\n  /* For cases where the key is like: 'general.something.thing' */\n\n\n  if (Object.prototype.hasOwnProperty.call(obj, path)) {\n    return obj[path];\n  }\n\n  return path.split('.').reduce((p, c) => p?.[c], obj);\n}\n\nfunction setValue(obj, prop, val) {\n  obj = { ...obj\n  };\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : { ...acc[part]\n      };\n    }\n\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\n\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n\n  return collection ? collection.length : 0;\n}\n\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\nfunction isObject(item) {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\\s+|_|-|\\//g, '');\n}\n\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\n\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n\n  return null;\n}\n\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\n\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\n\nfunction unflatten(obj) {\n  return unflatten$1(obj);\n}\n\nfunction flatten(obj) {\n  return flatten$1(obj, {\n    safe: true\n  });\n}\n\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => {\n    return {\n      defaultLang: 'en'\n    };\n  }\n});\nconst defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\n\nfunction translocoConfig(config = defaultConfig) {\n  return { ...defaultConfig,\n    ...config\n  };\n}\n\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\n\nclass DefaultTranspiler {\n  constructor(userConfig) {\n    this.interpolationMatcher = resolveMatcher(userConfig);\n  }\n\n  transpile(value, params = {}, translation) {\n    if (isString(value)) {\n      return value.replace(this.interpolationMatcher, (_, match) => {\n        match = match.trim();\n\n        if (isDefined(params[match])) {\n          return params[match];\n        }\n\n        return isDefined(translation[match]) ? this.transpile(translation[match], params, translation) : '';\n      });\n    } else if (params) {\n      if (isObject(value)) {\n        value = this.handleObject(value, params, translation);\n      } else if (Array.isArray(value)) {\n        value = this.handleArray(value, params, translation);\n      }\n    }\n\n    return value;\n  }\n  /**\n   *\n   * @example\n   *\n   * const en = {\n   *  a: {\n   *    b: {\n   *      c: \"Hello {{ value }}\"\n   *    }\n   *  }\n   * }\n   *\n   * const params =  {\n   *  \"b.c\": { value: \"Transloco \"}\n   * }\n   *\n   * service.selectTranslate('a', params);\n   *\n   * // the first param will be the result of `en.a`.\n   * // the second param will be `params`.\n   * parser.transpile(value, params, {});\n   *\n   *\n   */\n\n\n  handleObject(value, params = {}, translation) {\n    let result = value;\n    Object.keys(params).forEach(p => {\n      // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n      const v = getValue(result, p); // get the params of \"b.c\" => { value: \"Transloco\" }\n\n      const getParams = getValue(params, p); // transpile the value => \"Hello Transloco\"\n\n      const transpiled = this.transpile(v, getParams, translation); // set \"b.c\" to `transpiled`\n\n      result = setValue(result, p, transpiled);\n    });\n    return result;\n  }\n\n  handleArray(value, params = {}, translation) {\n    return value.map(v => this.transpile(v, params, translation));\n  }\n\n}\n\nDefaultTranspiler.ɵfac = function DefaultTranspiler_Factory(t) {\n  return new (t || DefaultTranspiler)(i0.ɵɵinject(TRANSLOCO_CONFIG, 8));\n};\n\nDefaultTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultTranspiler,\n  factory: DefaultTranspiler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nfunction resolveMatcher(userConfig) {\n  const [start, end] = userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation;\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\n\nfunction getFunctionArgs(argsString) {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n\n    args.push(value);\n  }\n\n  return args;\n}\n\nclass FunctionalTranspiler extends DefaultTranspiler {\n  constructor(injector) {\n    super();\n    this.injector = injector;\n  }\n\n  transpile(value, params = {}, translation) {\n    let transpiled = value;\n\n    if (isString(value)) {\n      transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match, functionName, args) => {\n        try {\n          const func = this.injector.get(functionName);\n          return func.transpile(...getFunctionArgs(args));\n        } catch (e) {\n          let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n\n          if (e.message.includes('NullInjectorError')) {\n            message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n          }\n\n          throw new Error(message);\n        }\n      });\n    }\n\n    return super.transpile(transpiled, params, translation);\n  }\n\n}\n\nFunctionalTranspiler.ɵfac = function FunctionalTranspiler_Factory(t) {\n  return new (t || FunctionalTranspiler)(i0.ɵɵinject(i0.Injector));\n};\n\nFunctionalTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FunctionalTranspiler,\n  factory: FunctionalTranspiler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FunctionalTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\n\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\n\nclass DefaultHandler {\n  handle(key, config) {\n    if (config.missingHandler.logMissingKey && !config.prodMode) {\n      const msg = `Missing translation for '${key}'`;\n      console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n    }\n\n    return key;\n  }\n\n}\n\nDefaultHandler.ɵfac = function DefaultHandler_Factory(t) {\n  return new (t || DefaultHandler)();\n};\n\nDefaultHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultHandler,\n  factory: DefaultHandler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultHandler, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\n\nclass DefaultInterceptor {\n  preSaveTranslation(translation) {\n    return translation;\n  }\n\n  preSaveTranslationKey(_, value) {\n    return value;\n  }\n\n}\n\nDefaultInterceptor.ɵfac = function DefaultInterceptor_Factory(t) {\n  return new (t || DefaultInterceptor)();\n};\n\nDefaultInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultInterceptor,\n  factory: DefaultInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultInterceptor, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\n\nclass DefaultFallbackStrategy {\n  constructor(userConfig) {\n    this.userConfig = userConfig;\n  }\n\n  getNextLangs() {\n    const fallbackLang = this.userConfig.fallbackLang;\n\n    if (!fallbackLang) {\n      throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n    }\n\n    return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n  }\n\n}\n\nDefaultFallbackStrategy.ɵfac = function DefaultFallbackStrategy_Factory(t) {\n  return new (t || DefaultFallbackStrategy)(i0.ɵɵinject(TRANSLOCO_CONFIG));\n};\n\nDefaultFallbackStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultFallbackStrategy,\n  factory: DefaultFallbackStrategy.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultFallbackStrategy, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nfunction mergeConfig(defaultConfig, userConfig) {\n  return { ...defaultConfig,\n    ...userConfig,\n    missingHandler: { ...defaultConfig.missingHandler,\n      ...userConfig.missingHandler\n    },\n    flatten: { ...defaultConfig.flatten,\n      ...userConfig.flatten\n    }\n  };\n}\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\n\n\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\n\n\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\n\n\nfunction getPipeValue(str, value, char = '|') {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n\n  return [false, ''];\n}\n\nfunction shouldListenToLangChanges(service, lang) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n\n  if (!hasStatic) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return !!service.config.reRenderOnLangChange;\n  } // We have 'lang|static' so don't listen to lang changes\n\n\n  return false;\n}\n\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ? source => source : take(1);\n}\n\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\n\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : undefined;\n}\n\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang)\n  };\n}\n\nfunction resolveLoader(options) {\n  const {\n    path,\n    inlineLoader,\n    mainLoader,\n    data\n  } = options;\n\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n\n    return inlineLoader[path]().then(res => res.default ? res.default : res);\n  }\n\n  return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders({\n  mainLoader,\n  path,\n  data,\n  fallbackPath,\n  inlineLoader\n}) {\n  const paths = fallbackPath ? [path, fallbackPath] : [path];\n  return paths.map(path => {\n    const loader = resolveLoader({\n      path,\n      mainLoader,\n      inlineLoader,\n      data\n    });\n    return from(loader).pipe(map(translation => ({\n      translation,\n      lang: path\n    })));\n  });\n}\n\nlet service;\n\nfunction translate(key, params = {}, lang) {\n  return service.translate(key, params, lang);\n}\n\nfunction translateObject(key, params = {}, lang) {\n  return service.translateObject(key, params, lang);\n}\n\nclass TranslocoService {\n  constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n    this.loader = loader;\n    this.parser = parser;\n    this.missingHandler = missingHandler;\n    this.interceptor = interceptor;\n    this.userConfig = userConfig;\n    this.fallbackStrategy = fallbackStrategy;\n    this.subscription = null;\n    this.translations = new Map();\n    this.cache = new Map();\n    this.defaultLang = '';\n    this.availableLangs = [];\n    this.isResolvedMissingOnce = false;\n    this.failedLangs = new Set();\n    this.events = new Subject();\n    this.events$ = this.events.asObservable();\n\n    if (!this.loader) {\n      this.loader = new DefaultLoader(this.translations);\n    }\n\n    service = this;\n    this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n    this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n    this.setFallbackLangForMissingTranslation(this.mergedConfig);\n    this.setDefaultLang(this.mergedConfig.defaultLang);\n    this.lang = new BehaviorSubject(this.getDefaultLang()); // Don't use distinctUntilChanged as we need the ability to update\n    // the value when using setTranslation or setTranslationKeys\n\n    this.langChanges$ = this.lang.asObservable();\n    /**\n     * When we have a failure, we want to define the next language that succeeded as the active\n     */\n\n    this.subscription = this.events$.subscribe(e => {\n      if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n        this.setActiveLang(e.payload.langName);\n      }\n    });\n  }\n\n  get config() {\n    return this.mergedConfig;\n  }\n\n  getDefaultLang() {\n    return this.defaultLang;\n  }\n\n  setDefaultLang(lang) {\n    this.defaultLang = lang;\n  }\n\n  getActiveLang() {\n    return this.lang.getValue();\n  }\n\n  setActiveLang(lang) {\n    this.lang.next(lang);\n    this.parser.onLangChanged?.(lang);\n    this.events.next({\n      type: 'langChanged',\n      payload: getEventPayload(lang)\n    });\n    return this;\n  }\n\n  setAvailableLangs(langs) {\n    this.availableLangs = langs;\n  }\n  /**\n   * Gets the available languages.\n   *\n   * @returns\n   * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n   * depending on how the available languages are set in your module.\n   */\n\n\n  getAvailableLangs() {\n    return this.availableLangs;\n  }\n\n  load(path, options = {}) {\n    const cached = this.cache.get(path);\n\n    if (cached) {\n      return cached;\n    }\n\n    let loadTranslation;\n\n    const isScope = this._isLangScoped(path);\n\n    let scope;\n\n    if (isScope) {\n      scope = getScopeFromLang(path);\n    }\n\n    const loadersOptions = {\n      path,\n      mainLoader: this.loader,\n      inlineLoader: options.inlineLoader,\n      data: isScope ? {\n        scope: scope\n      } : undefined\n    };\n\n    if (this.useFallbackTranslation(path)) {\n      // if the path is scope the fallback should be `scope/fallbackLang`;\n      const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n      const loaders = getFallbacksLoaders({ ...loadersOptions,\n        fallbackPath: fallback\n      });\n      loadTranslation = forkJoin(loaders);\n    } else {\n      const loader = resolveLoader(loadersOptions);\n      loadTranslation = from(loader);\n    }\n\n    const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(translation => {\n      if (Array.isArray(translation)) {\n        translation.forEach(t => {\n          this.handleSuccess(t.lang, t.translation); // Save the fallback in cache so we'll not create a redundant request\n\n          if (t.lang !== path) {\n            this.cache.set(t.lang, of({}));\n          }\n        });\n        return;\n      }\n\n      this.handleSuccess(path, translation);\n    }), catchError(error => {\n      if (!this.mergedConfig.prodMode) {\n        console.error(`Error while trying to load \"${path}\"`, error);\n      }\n\n      return this.handleFailure(path, options);\n    }), shareReplay(1));\n    this.cache.set(path, load$);\n    return load$;\n  }\n  /**\n   * Gets the instant translated value of a key\n   *\n   * @example\n   *\n   * translate<string>('hello')\n   * translate('hello', { value: 'value' })\n   * translate<string[]>(['hello', 'key'])\n   * translate('hello', { }, 'en')\n   * translate('scope.someKey', { }, 'en')\n   */\n\n\n  translate(key, params = {}, lang = this.getActiveLang()) {\n    if (!key) return key;\n    const {\n      scope,\n      resolveLang\n    } = this.resolveLangAndScope(lang);\n\n    if (Array.isArray(key)) {\n      return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n    }\n\n    key = scope ? `${scope}.${key}` : key;\n    const translation = this.getTranslation(resolveLang);\n    const value = translation[key];\n\n    if (!value) {\n      return this._handleMissingKey(key, value, params);\n    }\n\n    return this.parser.transpile(value, params, translation);\n  }\n  /**\n   * Gets the translated value of a key as observable\n   *\n   * @example\n   *\n   * selectTranslate<string>('hello').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n   *\n   */\n\n\n  selectTranslate(key, params, lang, _isObject = false) {\n    let inlineLoader;\n\n    const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)));\n\n    if (isNil(lang)) {\n      return this.langChanges$.pipe(switchMap(lang => load(lang)));\n    }\n\n    if (isScopeObject(lang)) {\n      // it's a scope object.\n      const providerScope = lang;\n      lang = providerScope.scope;\n      inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n    }\n\n    lang = lang;\n\n    if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n      return load(lang);\n    } // it's a scope\n\n\n    const scope = lang;\n    return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, {\n      inlineLoader\n    })));\n  }\n  /**\n   * Whether the scope with lang\n   *\n   * @example\n   *\n   * todos/en => true\n   * todos => false\n   */\n\n\n  isScopeWithLang(lang) {\n    return this.isLang(getLangFromScope(lang));\n  }\n\n  translateObject(key, params = {}, lang = this.getActiveLang()) {\n    if (isString(key) || Array.isArray(key)) {\n      const {\n        resolveLang,\n        scope\n      } = this.resolveLangAndScope(lang);\n\n      if (Array.isArray(key)) {\n        return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n      }\n\n      const translation = this.getTranslation(resolveLang);\n      key = scope ? `${scope}.${key}` : key;\n      const value = unflatten(this.getObjectByKey(translation, key));\n      /* If an empty object was returned we want to try and translate the key as a string and not an object */\n\n      return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);\n    }\n\n    const translations = [];\n\n    for (const [_key, _params] of this.getEntries(key)) {\n      translations.push(this.translateObject(_key, _params, lang));\n    }\n\n    return translations;\n  }\n\n  selectTranslateObject(key, params, lang) {\n    if (isString(key) || Array.isArray(key)) {\n      return this.selectTranslate(key, params, lang, true);\n    }\n\n    const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n    /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n     * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n\n    return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(value => {\n      const translations = [value];\n\n      for (const [_key, _params] of rest) {\n        translations.push(this.translateObject(_key, _params, lang));\n      }\n\n      return translations;\n    }));\n  }\n\n  getTranslation(langOrScope) {\n    if (langOrScope) {\n      if (this.isLang(langOrScope)) {\n        return this.translations.get(langOrScope) || {};\n      } else {\n        // This is a scope, build the scope value from the translation object\n        const {\n          scope,\n          resolveLang\n        } = this.resolveLangAndScope(langOrScope);\n        const translation = this.translations.get(resolveLang) || {};\n        return this.getObjectByKey(translation, scope);\n      }\n    }\n\n    return this.translations;\n  }\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * selectTranslation().subscribe() - will return the current lang translation\n   * selectTranslation('es').subscribe()\n   * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n   * selectTranslation('admin-page/es').subscribe()\n   */\n\n\n  selectTranslation(lang) {\n    let language$ = this.langChanges$;\n\n    if (lang) {\n      const scopeLangSpecified = getLangFromScope(lang) !== lang;\n\n      if (this.isLang(lang) || scopeLangSpecified) {\n        language$ = of(lang);\n      } else {\n        language$ = this.langChanges$.pipe(map(currentLang => `${lang}/${currentLang}`));\n      }\n    }\n\n    return language$.pipe(switchMap(language => this.load(language).pipe(map(() => this.getTranslation(language)))));\n  }\n  /**\n   * Sets or merge a given translation object to current lang\n   *\n   * @example\n   *\n   * setTranslation({ ... })\n   * setTranslation({ ... }, 'en')\n   * setTranslation({ ... }, 'es', { merge: false } )\n   * setTranslation({ ... }, 'todos/en', { merge: false } )\n   */\n\n\n  setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n    const defaults = {\n      merge: true,\n      emitChange: true\n    };\n    const mergedOptions = { ...defaults,\n      ...options\n    };\n    const scope = getScopeFromLang(lang);\n    /**\n     * If this isn't a scope we use the whole translation as is\n     * otherwise we need to flat the scope and use it\n     */\n\n    let flattenScopeOrTranslation = translation; // Merged the scoped language into the active language\n\n    if (scope) {\n      const key = this.getMappedScope(scope);\n      flattenScopeOrTranslation = flatten({\n        [key]: translation\n      });\n    }\n\n    const currentLang = scope ? getLangFromScope(lang) : lang;\n    const mergedTranslation = { ...(mergedOptions.merge && this.getTranslation(currentLang)),\n      ...flattenScopeOrTranslation\n    };\n    const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n    const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n    this.translations.set(currentLang, withHook);\n    mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n  }\n  /**\n   * Sets translation key with given value\n   *\n   * @example\n   *\n   * setTranslationKey('key', 'value')\n   * setTranslationKey('key.nested', 'value')\n   * setTranslationKey('key.nested', 'value', 'en')\n   * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n   */\n\n\n  setTranslationKey(key, value, // Todo: Add the lang to the options in v3\n  lang = this.getActiveLang(), options = {}) {\n    const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n    const newValue = {\n      [key]: withHook\n    };\n    this.setTranslation(newValue, lang, { ...options,\n      merge: true\n    });\n  }\n  /**\n   * Sets the fallback lang for the currently active language\n   * @param fallbackLang\n   */\n\n\n  setFallbackLangForMissingTranslation({\n    fallbackLang\n  }) {\n    const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n\n    if (fallbackLang && this.useFallbackTranslation(lang)) {\n      this.firstFallbackLang = lang;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  _handleMissingKey(key, value, params) {\n    if (this.config.missingHandler.allowEmpty && value === '') {\n      return '';\n    }\n\n    if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n      // We need to set it to true to prevent a loop\n      this.isResolvedMissingOnce = true;\n      const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n      this.isResolvedMissingOnce = false;\n      return fallbackValue;\n    }\n\n    return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n  }\n  /**\n   * @internal\n   */\n\n\n  _isLangScoped(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) === -1;\n  }\n  /**\n   * Checks if a given string is one of the specified available languages.\n   * @returns\n   * True if the given string is an available language.\n   * False if the given string is not an available language.\n   */\n\n\n  isLang(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) !== -1;\n  }\n  /**\n   * @internal\n   *\n   * We always want to make sure the global lang is loaded\n   * before loading the scope since you can access both via the pipe/directive.\n   */\n\n\n  _loadDependencies(path, inlineLoader) {\n    const mainLang = getLangFromScope(path);\n\n    if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n      return combineLatest(this.load(mainLang), this.load(path, {\n        inlineLoader\n      }));\n    }\n\n    return this.load(path, {\n      inlineLoader\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  _completeScopeWithLang(langOrScope) {\n    if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n      return `${langOrScope}/${this.getActiveLang()}`;\n    }\n\n    return langOrScope;\n  }\n  /**\n   * @internal\n   */\n\n\n  _setScopeAlias(scope, alias) {\n    if (!this.mergedConfig.scopeMapping) {\n      this.mergedConfig.scopeMapping = {};\n    }\n\n    this.mergedConfig.scopeMapping[scope] = alias;\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n\n      this.subscription = null;\n    } // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n    // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n    // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n    // and destroyed per each HTTP request, but any service is not getting GC'd.\n\n\n    this.cache.clear();\n  }\n\n  isLoadedTranslation(lang) {\n    return size(this.getTranslation(lang));\n  }\n\n  getAvailableLangsIds() {\n    const first = this.getAvailableLangs()[0];\n\n    if (isString(first)) {\n      return this.getAvailableLangs();\n    }\n\n    return this.getAvailableLangs().map(l => l.id);\n  }\n\n  getMissingHandlerData() {\n    return { ...this.config,\n      activeLang: this.getActiveLang(),\n      availableLangs: this.availableLangs,\n      defaultLang: this.defaultLang\n    };\n  }\n  /**\n   * Use a fallback translation set for missing keys of the primary language\n   * This is unrelated to the fallback language (which changes the active language)\n   */\n\n\n  useFallbackTranslation(lang) {\n    return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n  }\n\n  handleSuccess(lang, translation) {\n    this.setTranslation(translation, lang, {\n      emitChange: false\n    });\n    this.events.next({\n      wasFailure: !!this.failedLangs.size,\n      type: 'translationLoadSuccess',\n      payload: getEventPayload(lang)\n    });\n    this.failedLangs.forEach(l => this.cache.delete(l));\n    this.failedLangs.clear();\n  }\n\n  handleFailure(lang, loadOptions) {\n    // When starting to load a first choice language, initialize\n    // the failed counter and resolve the fallback langs.\n    if (isNil(loadOptions.failedCounter)) {\n      loadOptions.failedCounter = 0;\n\n      if (!loadOptions.fallbackLangs) {\n        loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n      }\n    }\n\n    const splitted = lang.split('/');\n    const fallbacks = loadOptions.fallbackLangs;\n    const nextLang = fallbacks[loadOptions.failedCounter];\n    this.failedLangs.add(lang); // This handles the case where a loaded fallback language is requested again\n\n    if (this.cache.has(nextLang)) {\n      this.handleSuccess(nextLang, this.getTranslation(nextLang));\n      return EMPTY;\n    }\n\n    const isFallbackLang = nextLang === splitted[splitted.length - 1];\n\n    if (!nextLang || isFallbackLang) {\n      let msg = `Unable to load translation and all the fallback languages`;\n\n      if (splitted.length > 1) {\n        msg += `, did you misspelled the scope name?`;\n      }\n\n      throw new Error(msg);\n    }\n\n    let resolveLang = nextLang; // if it's scoped lang\n\n    if (splitted.length > 1) {\n      // We need to resolve it to:\n      // todos/langNotExists => todos/nextLang\n      splitted[splitted.length - 1] = nextLang;\n      resolveLang = splitted.join('/');\n    }\n\n    loadOptions.failedCounter++;\n    this.events.next({\n      type: 'translationLoadFailure',\n      payload: getEventPayload(lang)\n    });\n    return this.load(resolveLang, loadOptions);\n  }\n\n  getMappedScope(scope) {\n    const {\n      scopeMapping = {}\n    } = this.config;\n    return scopeMapping[scope] || toCamelCase(scope);\n  }\n  /**\n   * If lang is scope we need to check the following cases:\n   * todos/es => in this case we should take `es` as lang\n   * todos => in this case we should set the active lang as lang\n   */\n\n\n  resolveLangAndScope(lang) {\n    let resolveLang = lang;\n    let scope;\n\n    if (this._isLangScoped(lang)) {\n      // en for example\n      const langFromScope = getLangFromScope(lang); // en is lang\n\n      const hasLang = this.isLang(langFromScope); // take en\n\n      resolveLang = hasLang ? langFromScope : this.getActiveLang(); // find the scope\n\n      scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n    }\n\n    return {\n      scope,\n      resolveLang\n    };\n  }\n\n  getObjectByKey(translation, key) {\n    const result = {};\n    const prefix = `${key}.`;\n\n    for (const currentKey in translation) {\n      if (currentKey.startsWith(prefix)) {\n        result[currentKey.replace(prefix, '')] = translation[currentKey];\n      }\n    }\n\n    return result;\n  }\n\n  getEntries(key) {\n    return key instanceof Map ? key.entries() : Object.entries(key);\n  }\n\n}\n\nTranslocoService.ɵfac = function TranslocoService_Factory(t) {\n  return new (t || TranslocoService)(i0.ɵɵinject(TRANSLOCO_LOADER, 8), i0.ɵɵinject(TRANSLOCO_TRANSPILER), i0.ɵɵinject(TRANSLOCO_MISSING_HANDLER), i0.ɵɵinject(TRANSLOCO_INTERCEPTOR), i0.ɵɵinject(TRANSLOCO_CONFIG), i0.ɵɵinject(TRANSLOCO_FALLBACK_STRATEGY));\n};\n\nTranslocoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TranslocoService,\n  factory: TranslocoService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LOADER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TRANSPILER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_MISSING_HANDLER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_INTERCEPTOR]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_FALLBACK_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\n\nclass TranslocoLoaderComponent {}\n\nTranslocoLoaderComponent.ɵfac = function TranslocoLoaderComponent_Factory(t) {\n  return new (t || TranslocoLoaderComponent)();\n};\n\nTranslocoLoaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: TranslocoLoaderComponent,\n  selectors: [[\"ng-component\"]],\n  inputs: {\n    html: \"html\"\n  },\n  decls: 1,\n  vars: 1,\n  consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n  template: function TranslocoLoaderComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"div\", 0);\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"innerHTML\", ctx.html, i0.ɵɵsanitizeHtml);\n    }\n  },\n  encapsulation: 2\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoLoaderComponent, [{\n    type: Component,\n    args: [{\n      template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `\n    }]\n  }], null, {\n    html: [{\n      type: Input\n    }]\n  });\n})();\n\nclass TemplateHandler {\n  constructor(view, vcr) {\n    this.view = view;\n    this.vcr = vcr;\n    this.injector = this.vcr.injector;\n  }\n\n  attachView() {\n    if (this.view instanceof TemplateRef) {\n      this.vcr.createEmbeddedView(this.view);\n    } else if (isString(this.view)) {\n      const componentRef = this.createComponent(TranslocoLoaderComponent);\n      componentRef.instance.html = this.view;\n      componentRef.hostView.detectChanges();\n    } else {\n      this.createComponent(this.view);\n    }\n  }\n\n  detachView() {\n    this.vcr.clear();\n  }\n\n  createComponent(cmp) {\n    const cfr = this.injector.get(ComponentFactoryResolver);\n    const factory = cfr.resolveComponentFactory(cmp);\n    return this.vcr.createComponent(factory);\n  }\n\n}\n\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nclass LangResolver {\n  constructor() {\n    this.initialized = false;\n  } // inline => provider => active\n\n\n  resolve({\n    inline,\n    provider,\n    active\n  }) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n\n    if (provider) {\n      const [, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n\n    if (inline) {\n      const [, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n\n    this.initialized = true;\n    return lang;\n  }\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n\n\n  resolveLangBasedOnScope(lang) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n\n\n  resolveLangPath(lang, scope) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n\n}\n\nclass ScopeResolver {\n  constructor(translocoService) {\n    this.translocoService = translocoService;\n  } // inline => provider\n\n\n  resolve({\n    inline,\n    provider\n  } = {\n    inline: undefined,\n    provider: undefined\n  }) {\n    if (inline) {\n      return inline;\n    }\n\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const {\n          scope,\n          alias = toCamelCase(scope)\n        } = provider;\n\n        this.translocoService._setScopeAlias(scope, alias);\n\n        return scope;\n      }\n\n      return provider;\n    }\n\n    return undefined;\n  }\n\n}\n\nclass TranslocoDirective {\n  constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {\n    this.translocoService = translocoService;\n    this.tpl = tpl;\n    this.providerScope = providerScope;\n    this.providerLang = providerLang;\n    this.providedLoadingTpl = providedLoadingTpl;\n    this.vcr = vcr;\n    this.cdr = cdr;\n    this.host = host;\n    this.renderer = renderer;\n    this.subscription = null;\n    this.translationMemo = {};\n    this.params = {}; // Whether we already rendered the view once\n\n    this.initialized = false;\n    this.langResolver = new LangResolver();\n    this.scopeResolver = new ScopeResolver(this.translocoService);\n    this.strategy = this.tpl === null ? 'attribute' : 'structural';\n  }\n\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n\n  ngOnInit() {\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n    this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: this.inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => {\n      this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n      this.strategy === 'attribute' ? this.attributeStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n      this.cdr.markForCheck();\n      this.initialized = true;\n    });\n    const loadingTpl = this.getLoadingTpl();\n\n    if (!this.initialized && loadingTpl) {\n      this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n      this.loaderTplHandler.attachView();\n    }\n  }\n\n  ngOnChanges(changes) {\n    // We need to support dynamic keys/params, so if this is not the first change CD cycle\n    // we need to run the function again in order to update the value\n    if (this.strategy === 'attribute') {\n      const notInit = Object.keys(changes).some(v => !changes[v].firstChange);\n      notInit && this.attributeStrategy();\n    }\n  }\n\n  attributeStrategy() {\n    this.detachLoader();\n    this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));\n  }\n\n  structuralStrategy(lang, read) {\n    this.translationMemo = {};\n\n    if (this.view) {\n      // when the lang changes we need to change the reference so Angular will update the view\n      this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n      this.view.context['currentLang'] = this.currentLang;\n    } else {\n      this.detachLoader();\n      this.view = this.vcr.createEmbeddedView(this.tpl, {\n        $implicit: this.getTranslateFn(lang, read),\n        currentLang: this.currentLang\n      });\n    }\n  }\n\n  getTranslateFn(lang, read) {\n    return (key, params) => {\n      const withRead = read ? `${read}.${key}` : key;\n      const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n\n      if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n        return this.translationMemo[withParams].value;\n      }\n\n      this.translationMemo[withParams] = {\n        params,\n        value: this.translocoService.translate(withRead, params, lang)\n      };\n      return this.translationMemo[withParams].value;\n    };\n  }\n\n  getLoadingTpl() {\n    return this.inlineTpl || this.providedLoadingTpl;\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n\n      this.subscription = null;\n    }\n  }\n\n  detachLoader() {\n    this.loaderTplHandler?.detachView();\n  }\n\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: this.inlineScope,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n\n}\n\nTranslocoDirective.ɵfac = function TranslocoDirective_Factory(t) {\n  return new (t || TranslocoDirective)(i0.ɵɵdirectiveInject(TranslocoService), i0.ɵɵdirectiveInject(i0.TemplateRef, 8), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LOADING_TEMPLATE, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\n\nTranslocoDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: TranslocoDirective,\n  selectors: [[\"\", \"transloco\", \"\"]],\n  inputs: {\n    key: [\"transloco\", \"key\"],\n    params: [\"translocoParams\", \"params\"],\n    inlineScope: [\"translocoScope\", \"inlineScope\"],\n    inlineRead: [\"translocoRead\", \"inlineRead\"],\n    inlineLang: [\"translocoLang\", \"inlineLang\"],\n    inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[transloco]'\n    }]\n  }], function () {\n    return [{\n      type: TranslocoService\n    }, {\n      type: i0.TemplateRef,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_SCOPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LANG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LOADING_TEMPLATE]\n      }]\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }];\n  }, {\n    key: [{\n      type: Input,\n      args: ['transloco']\n    }],\n    params: [{\n      type: Input,\n      args: ['translocoParams']\n    }],\n    inlineScope: [{\n      type: Input,\n      args: ['translocoScope']\n    }],\n    inlineRead: [{\n      type: Input,\n      args: ['translocoRead']\n    }],\n    inlineLang: [{\n      type: Input,\n      args: ['translocoLang']\n    }],\n    inlineTpl: [{\n      type: Input,\n      args: ['translocoLoadingTpl']\n    }]\n  });\n})();\n\nclass TranslocoPipe {\n  constructor(translocoService, providerScope, providerLang, cdr) {\n    this.translocoService = translocoService;\n    this.providerScope = providerScope;\n    this.providerLang = providerLang;\n    this.cdr = cdr;\n    this.subscription = null;\n    this.lastValue = '';\n    this.langResolver = new LangResolver();\n    this.scopeResolver = new ScopeResolver(this.translocoService);\n  } // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n  // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n\n\n  transform(key, params, inlineLang) {\n    if (!key) {\n      return key;\n    }\n\n    const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n\n    if (keyName === this.lastKey) {\n      return this.lastValue;\n    }\n\n    this.lastKey = keyName;\n    this.subscription?.unsubscribe();\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n    this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => this.updateValue(key, params));\n    return this.lastValue;\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n\n      this.subscription = null;\n    }\n  }\n\n  updateValue(key, params) {\n    const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n    this.lastValue = this.translocoService.translate(key, params, lang);\n    this.cdr.markForCheck();\n  }\n\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: undefined,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n\n}\n\nTranslocoPipe.ɵfac = function TranslocoPipe_Factory(t) {\n  return new (t || TranslocoPipe)(i0.ɵɵdirectiveInject(TranslocoService, 16), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 24), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 24), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n};\n\nTranslocoPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"transloco\",\n  type: TranslocoPipe,\n  pure: false\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'transloco',\n      pure: false\n    }]\n  }], function () {\n    return [{\n      type: TranslocoService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_SCOPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LANG]\n      }]\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, null);\n})();\n\nconst defaultProviders = [{\n  provide: TRANSLOCO_TRANSPILER,\n  useClass: DefaultTranspiler,\n  deps: [TRANSLOCO_CONFIG]\n}, {\n  provide: TRANSLOCO_MISSING_HANDLER,\n  useClass: DefaultHandler\n}, {\n  provide: TRANSLOCO_INTERCEPTOR,\n  useClass: DefaultInterceptor\n}, {\n  provide: TRANSLOCO_FALLBACK_STRATEGY,\n  useClass: DefaultFallbackStrategy,\n  deps: [TRANSLOCO_CONFIG]\n}];\n\nclass TranslocoModule {}\n\nTranslocoModule.ɵfac = function TranslocoModule_Factory(t) {\n  return new (t || TranslocoModule)();\n};\n\nTranslocoModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: TranslocoModule\n});\nTranslocoModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [defaultProviders]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n      providers: [defaultProviders],\n      exports: [TranslocoDirective, TranslocoPipe]\n    }]\n  }], null, null);\n})();\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\n\nclass TestingLoader {\n  constructor(langs) {\n    this.langs = langs;\n  }\n\n  getTranslation(lang) {\n    return of(this.langs[lang]);\n  }\n\n}\n\nTestingLoader.ɵfac = function TestingLoader_Factory(t) {\n  return new (t || TestingLoader)(i0.ɵɵinject(TRANSLOCO_TEST_LANGS));\n};\n\nTestingLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TestingLoader,\n  factory: TestingLoader.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestingLoader, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TEST_LANGS]\n      }]\n    }];\n  }, null);\n})();\n\nfunction initTranslocoService(service, langs = {}, options) {\n  const preloadAllLangs = () => options.preloadLangs ? Promise.all(Object.keys(langs).map(lang => service.load(lang).toPromise())) : Promise.resolve();\n\n  return preloadAllLangs;\n}\n\nclass TranslocoTestingModule {\n  static forRoot(options) {\n    return {\n      ngModule: TranslocoTestingModule,\n      providers: [{\n        provide: TRANSLOCO_TEST_LANGS,\n        useValue: options.langs\n      }, {\n        provide: TRANSLOCO_TEST_OPTIONS,\n        useValue: options\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: initTranslocoService,\n        deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n        multi: true\n      }, {\n        provide: TRANSLOCO_LOADER,\n        useClass: TestingLoader\n      }, defaultProviders, {\n        provide: TRANSLOCO_CONFIG,\n        useValue: translocoConfig({\n          prodMode: true,\n          missingHandler: {\n            logMissingKey: false\n          },\n          ...options.translocoConfig\n        })\n      }]\n    };\n  }\n\n}\n\nTranslocoTestingModule.ɵfac = function TranslocoTestingModule_Factory(t) {\n  return new (t || TranslocoTestingModule)();\n};\n\nTranslocoTestingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: TranslocoTestingModule\n});\nTranslocoTestingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [TranslocoModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoTestingModule, [{\n    type: NgModule,\n    args: [{\n      exports: [TranslocoModule]\n    }]\n  }], null, null);\n})();\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\n\n\nfunction getBrowserLang() {\n  let browserLang = getBrowserCultureLang();\n\n  if (!browserLang || !isBrowser()) {\n    return undefined;\n  }\n\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\n\n\nfunction getBrowserCultureLang() {\n  if (!isBrowser()) {\n    return '';\n  }\n\n  const navigator = window.navigator;\n  let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n  return browserCultureLang;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten };","map":{"version":3,"sources":["/Users/christoph/Desktop/angular-i18n-transloco/node_modules/@ngneat/transloco/fesm2020/ngneat-transloco.mjs"],"names":["i0","InjectionToken","Injectable","Optional","Inject","Component","Input","TemplateRef","ComponentFactoryResolver","Directive","Pipe","NgModule","APP_INITIALIZER","of","from","Subject","BehaviorSubject","forkJoin","combineLatest","EMPTY","take","map","retry","tap","catchError","shareReplay","switchMap","unflatten","unflatten$1","flatten","flatten$1","DefaultLoader","constructor","translations","getTranslation","lang","get","TRANSLOCO_LOADER","getValue","obj","path","Object","prototype","hasOwnProperty","call","split","reduce","p","c","setValue","prop","val","lastIndex","length","acc","part","index","Array","isArray","slice","size","collection","isObject","keys","isEmpty","isFunction","isString","isNumber","item","coerceArray","value","toCamelCase","str","replace","word","toLowerCase","toUpperCase","isBrowser","window","isNil","undefined","isDefined","toNumber","isNaN","Number","parseFloat","isScopeObject","scope","hasInlineLoader","loader","safe","TRANSLOCO_CONFIG","providedIn","factory","defaultLang","defaultConfig","reRenderOnLangChange","prodMode","failedRetries","availableLangs","missingHandler","logMissingKey","useFallbackTranslation","allowEmpty","aot","interpolation","translocoConfig","config","TRANSLOCO_TRANSPILER","DefaultTranspiler","userConfig","interpolationMatcher","resolveMatcher","transpile","params","translation","_","match","trim","handleObject","handleArray","result","forEach","v","getParams","transpiled","ɵfac","ɵprov","type","decorators","args","start","end","RegExp","getFunctionArgs","argsString","splitted","i","push","FunctionalTranspiler","injector","functionName","func","e","message","includes","Error","Injector","TRANSLOCO_MISSING_HANDLER","DefaultHandler","handle","key","msg","console","warn","TRANSLOCO_INTERCEPTOR","DefaultInterceptor","preSaveTranslation","preSaveTranslationKey","TRANSLOCO_FALLBACK_STRATEGY","DefaultFallbackStrategy","getNextLangs","fallbackLang","mergeConfig","getScopeFromLang","pop","join","getLangFromScope","getPipeValue","char","lastItem","toString","shouldListenToLangChanges","service","hasStatic","listenOrNotOperator","listenToLangChange","source","prependScope","inlineLoader","resolveInlineLoader","providerScope","getEventPayload","langName","resolveLoader","options","mainLoader","data","pathLoader","then","res","default","getFallbacksLoaders","fallbackPath","paths","pipe","translate","translateObject","TranslocoService","parser","interceptor","fallbackStrategy","subscription","Map","cache","isResolvedMissingOnce","failedLangs","Set","events","events$","asObservable","mergedConfig","setAvailableLangs","setFallbackLangForMissingTranslation","setDefaultLang","getDefaultLang","langChanges$","subscribe","wasFailure","setActiveLang","payload","getActiveLang","next","onLangChanged","langs","getAvailableLangs","load","cached","loadTranslation","isScope","_isLangScoped","loadersOptions","fallback","firstFallbackLang","loaders","load$","t","handleSuccess","set","error","handleFailure","resolveLang","resolveLangAndScope","k","_handleMissingKey","selectTranslate","_isObject","isLang","isScopeWithLang","getObjectByKey","_key","_params","getEntries","selectTranslateObject","firstKey","firstParams","rest","langOrScope","selectTranslation","language$","scopeLangSpecified","currentLang","language","setTranslation","defaults","merge","emitChange","mergedOptions","flattenScopeOrTranslation","getMappedScope","mergedTranslation","flattenTranslation","withHook","setTranslationKey","newValue","fallbackValue","getMissingHandlerData","getAvailableLangsIds","indexOf","_loadDependencies","mainLang","isLoadedTranslation","_completeScopeWithLang","_setScopeAlias","alias","scopeMapping","ngOnDestroy","unsubscribe","clear","first","l","id","activeLang","delete","loadOptions","failedCounter","fallbackLangs","fallbacks","nextLang","add","has","isFallbackLang","langFromScope","hasLang","prefix","currentKey","startsWith","entries","TranslocoLoaderComponent","ɵcmp","template","html","TemplateHandler","view","vcr","attachView","createEmbeddedView","componentRef","createComponent","instance","hostView","detectChanges","detachView","cmp","cfr","resolveComponentFactory","TRANSLOCO_LANG","TRANSLOCO_LOADING_TEMPLATE","TRANSLOCO_SCOPE","LangResolver","initialized","resolve","inline","provider","active","extracted","resolveLangBasedOnScope","resolveLangPath","ScopeResolver","translocoService","TranslocoDirective","tpl","providerLang","providedLoadingTpl","cdr","host","renderer","translationMemo","langResolver","scopeResolver","strategy","ngTemplateContextGuard","dir","ctx","ngOnInit","inlineLang","resolveScope","attributeStrategy","structuralStrategy","inlineRead","markForCheck","loadingTpl","getLoadingTpl","loaderTplHandler","ngOnChanges","changes","notInit","some","firstChange","detachLoader","setProperty","nativeElement","read","context","getTranslateFn","$implicit","withRead","withParams","JSON","stringify","inlineTpl","resolvedScope","inlineScope","ViewContainerRef","ChangeDetectorRef","ElementRef","Renderer2","ɵdir","selector","TranslocoPipe","lastValue","transform","keyName","lastKey","updateValue","ɵpipe","name","pure","defaultProviders","provide","useClass","deps","TranslocoModule","ɵmod","ɵinj","declarations","providers","exports","TRANSLOCO_TEST_LANGS","TRANSLOCO_TEST_OPTIONS","TestingLoader","initTranslocoService","preloadAllLangs","preloadLangs","Promise","all","toPromise","TranslocoTestingModule","forRoot","ngModule","useValue","useFactory","multi","getBrowserLang","browserLang","getBrowserCultureLang","navigator","browserCultureLang","languages","browserLanguage","userLanguage"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nclass DefaultLoader {\n    constructor(translations) {\n        this.translations = translations;\n    }\n    getTranslation(lang) {\n        return of(this.translations.get(lang) || {});\n    }\n}\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n    if (!obj) {\n        return obj;\n    }\n    /* For cases where the key is like: 'general.something.thing' */\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n        return obj[path];\n    }\n    return path.split('.').reduce((p, c) => p?.[c], obj);\n}\nfunction setValue(obj, prop, val) {\n    obj = { ...obj };\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part])\n                ? acc[part].slice()\n                : { ...acc[part] };\n        }\n        return acc && acc[part];\n    }, obj);\n    return obj;\n}\nfunction size(collection) {\n    if (!collection) {\n        return 0;\n    }\n    if (Array.isArray(collection)) {\n        return collection.length;\n    }\n    if (isObject(collection)) {\n        return Object.keys(collection).length;\n    }\n    return collection ? collection.length : 0;\n}\nfunction isEmpty(collection) {\n    return size(collection) === 0;\n}\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\nfunction isString(val) {\n    return typeof val === 'string';\n}\nfunction isNumber(val) {\n    return typeof val === 'number';\n}\nfunction isObject(item) {\n    return !!item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nfunction toCamelCase(str) {\n    return str\n        .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase())\n        .replace(/\\s+|_|-|\\//g, '');\n}\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\nfunction isNil(value) {\n    return value === null || value === undefined;\n}\nfunction isDefined(value) {\n    return isNil(value) === false;\n}\nfunction toNumber(value) {\n    if (isNumber(value))\n        return value;\n    if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n        return Number(value);\n    }\n    return null;\n}\nfunction isScopeObject(item) {\n    return item && typeof item.scope === 'string';\n}\nfunction hasInlineLoader(item) {\n    return item && isObject(item.loader);\n}\nfunction unflatten(obj) {\n    return unflatten$1(obj);\n}\nfunction flatten(obj) {\n    return flatten$1(obj, { safe: true });\n}\n\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n    providedIn: 'root',\n    factory: () => {\n        return { defaultLang: 'en' };\n    },\n});\nconst defaultConfig = {\n    defaultLang: 'en',\n    reRenderOnLangChange: false,\n    prodMode: false,\n    failedRetries: 2,\n    availableLangs: [],\n    missingHandler: {\n        logMissingKey: true,\n        useFallbackTranslation: false,\n        allowEmpty: false,\n    },\n    flatten: {\n        aot: false,\n    },\n    interpolation: ['{{', '}}'],\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\nfunction translocoConfig(config = defaultConfig) {\n    return { ...defaultConfig, ...config };\n}\n\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n    constructor(userConfig) {\n        this.interpolationMatcher = resolveMatcher(userConfig);\n    }\n    transpile(value, params = {}, translation) {\n        if (isString(value)) {\n            return value.replace(this.interpolationMatcher, (_, match) => {\n                match = match.trim();\n                if (isDefined(params[match])) {\n                    return params[match];\n                }\n                return isDefined(translation[match])\n                    ? this.transpile(translation[match], params, translation)\n                    : '';\n            });\n        }\n        else if (params) {\n            if (isObject(value)) {\n                value = this.handleObject(value, params, translation);\n            }\n            else if (Array.isArray(value)) {\n                value = this.handleArray(value, params, translation);\n            }\n        }\n        return value;\n    }\n    /**\n     *\n     * @example\n     *\n     * const en = {\n     *  a: {\n     *    b: {\n     *      c: \"Hello {{ value }}\"\n     *    }\n     *  }\n     * }\n     *\n     * const params =  {\n     *  \"b.c\": { value: \"Transloco \"}\n     * }\n     *\n     * service.selectTranslate('a', params);\n     *\n     * // the first param will be the result of `en.a`.\n     * // the second param will be `params`.\n     * parser.transpile(value, params, {});\n     *\n     *\n     */\n    handleObject(value, params = {}, translation) {\n        let result = value;\n        Object.keys(params).forEach((p) => {\n            // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n            const v = getValue(result, p);\n            // get the params of \"b.c\" => { value: \"Transloco\" }\n            const getParams = getValue(params, p);\n            // transpile the value => \"Hello Transloco\"\n            const transpiled = this.transpile(v, getParams, translation);\n            // set \"b.c\" to `transpiled`\n            result = setValue(result, p, transpiled);\n        });\n        return result;\n    }\n    handleArray(value, params = {}, translation) {\n        return value.map((v) => this.transpile(v, params, translation));\n    }\n}\nDefaultTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultTranspiler, deps: [{ token: TRANSLOCO_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultTranspiler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\nfunction resolveMatcher(userConfig) {\n    const [start, end] = userConfig && userConfig.interpolation\n        ? userConfig.interpolation\n        : defaultConfig.interpolation;\n    return new RegExp(`${start}(.*?)${end}`, 'g');\n}\nfunction getFunctionArgs(argsString) {\n    const splitted = argsString ? argsString.split(',') : [];\n    const args = [];\n    for (let i = 0; i < splitted.length; i++) {\n        let value = splitted[i].trim();\n        while (value[value.length - 1] === '\\\\') {\n            i++;\n            value = value.replace('\\\\', ',') + splitted[i];\n        }\n        args.push(value);\n    }\n    return args;\n}\nclass FunctionalTranspiler extends DefaultTranspiler {\n    constructor(injector) {\n        super();\n        this.injector = injector;\n    }\n    transpile(value, params = {}, translation) {\n        let transpiled = value;\n        if (isString(value)) {\n            transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match, functionName, args) => {\n                try {\n                    const func = this.injector.get(functionName);\n                    return func.transpile(...getFunctionArgs(args));\n                }\n                catch (e) {\n                    let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n                    if (e.message.includes('NullInjectorError')) {\n                        message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n                    }\n                    throw new Error(message);\n                }\n            });\n        }\n        return super.transpile(transpiled, params, translation);\n    }\n}\nFunctionalTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: FunctionalTranspiler, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\nFunctionalTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: FunctionalTranspiler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: FunctionalTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\n\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nclass DefaultHandler {\n    handle(key, config) {\n        if (config.missingHandler.logMissingKey && !config.prodMode) {\n            const msg = `Missing translation for '${key}'`;\n            console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n        }\n        return key;\n    }\n}\nDefaultHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultHandler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultHandler, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nclass DefaultInterceptor {\n    preSaveTranslation(translation) {\n        return translation;\n    }\n    preSaveTranslationKey(_, value) {\n        return value;\n    }\n}\nDefaultInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultInterceptor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultInterceptor, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n    constructor(userConfig) {\n        this.userConfig = userConfig;\n    }\n    getNextLangs() {\n        const fallbackLang = this.userConfig.fallbackLang;\n        if (!fallbackLang) {\n            throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n        }\n        return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n    }\n}\nDefaultFallbackStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultFallbackStrategy, deps: [{ token: TRANSLOCO_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultFallbackStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultFallbackStrategy });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultFallbackStrategy, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\n\nfunction mergeConfig(defaultConfig, userConfig) {\n    return {\n        ...defaultConfig,\n        ...userConfig,\n        missingHandler: {\n            ...defaultConfig.missingHandler,\n            ...userConfig.missingHandler,\n        },\n        flatten: {\n            ...defaultConfig.flatten,\n            ...userConfig.flatten,\n        },\n    };\n}\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nfunction getScopeFromLang(lang) {\n    if (!lang) {\n        return '';\n    }\n    const split = lang.split('/');\n    split.pop();\n    return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nfunction getLangFromScope(lang) {\n    if (!lang) {\n        return '';\n    }\n    return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nfunction getPipeValue(str, value, char = '|') {\n    if (isString(str)) {\n        const splitted = str.split(char);\n        const lastItem = splitted.pop();\n        return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n    }\n    return [false, ''];\n}\nfunction shouldListenToLangChanges(service, lang) {\n    const [hasStatic] = getPipeValue(lang, 'static');\n    if (!hasStatic) {\n        // If we didn't get 'lang|static' check if it's set in the global level\n        return !!service.config.reRenderOnLangChange;\n    }\n    // We have 'lang|static' so don't listen to lang changes\n    return false;\n}\nfunction listenOrNotOperator(listenToLangChange) {\n    return listenToLangChange ? (source) => source : take(1);\n}\nfunction prependScope(inlineLoader, scope) {\n    return Object.keys(inlineLoader).reduce((acc, lang) => {\n        acc[`${scope}/${lang}`] = inlineLoader[lang];\n        return acc;\n    }, {});\n}\nfunction resolveInlineLoader(providerScope, scope) {\n    return hasInlineLoader(providerScope)\n        ? prependScope(providerScope.loader, scope)\n        : undefined;\n}\nfunction getEventPayload(lang) {\n    return {\n        scope: getScopeFromLang(lang) || null,\n        langName: getLangFromScope(lang),\n    };\n}\n\nfunction resolveLoader(options) {\n    const { path, inlineLoader, mainLoader, data } = options;\n    if (inlineLoader) {\n        const pathLoader = inlineLoader[path];\n        if (isFunction(pathLoader) === false) {\n            throw `You're using an inline loader but didn't provide a loader for ${path}`;\n        }\n        return inlineLoader[path]().then((res) => res.default ? res.default : res);\n    }\n    return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders({ mainLoader, path, data, fallbackPath, inlineLoader, }) {\n    const paths = fallbackPath ? [path, fallbackPath] : [path];\n    return paths.map((path) => {\n        const loader = resolveLoader({ path, mainLoader, inlineLoader, data });\n        return from(loader).pipe(map((translation) => ({\n            translation,\n            lang: path,\n        })));\n    });\n}\n\nlet service;\nfunction translate(key, params = {}, lang) {\n    return service.translate(key, params, lang);\n}\nfunction translateObject(key, params = {}, lang) {\n    return service.translateObject(key, params, lang);\n}\nclass TranslocoService {\n    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n        this.loader = loader;\n        this.parser = parser;\n        this.missingHandler = missingHandler;\n        this.interceptor = interceptor;\n        this.userConfig = userConfig;\n        this.fallbackStrategy = fallbackStrategy;\n        this.subscription = null;\n        this.translations = new Map();\n        this.cache = new Map();\n        this.defaultLang = '';\n        this.availableLangs = [];\n        this.isResolvedMissingOnce = false;\n        this.failedLangs = new Set();\n        this.events = new Subject();\n        this.events$ = this.events.asObservable();\n        if (!this.loader) {\n            this.loader = new DefaultLoader(this.translations);\n        }\n        service = this;\n        this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n        this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n        this.setFallbackLangForMissingTranslation(this.mergedConfig);\n        this.setDefaultLang(this.mergedConfig.defaultLang);\n        this.lang = new BehaviorSubject(this.getDefaultLang());\n        // Don't use distinctUntilChanged as we need the ability to update\n        // the value when using setTranslation or setTranslationKeys\n        this.langChanges$ = this.lang.asObservable();\n        /**\n         * When we have a failure, we want to define the next language that succeeded as the active\n         */\n        this.subscription = this.events$.subscribe((e) => {\n            if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n                this.setActiveLang(e.payload.langName);\n            }\n        });\n    }\n    get config() {\n        return this.mergedConfig;\n    }\n    getDefaultLang() {\n        return this.defaultLang;\n    }\n    setDefaultLang(lang) {\n        this.defaultLang = lang;\n    }\n    getActiveLang() {\n        return this.lang.getValue();\n    }\n    setActiveLang(lang) {\n        this.lang.next(lang);\n        this.parser.onLangChanged?.(lang);\n        this.events.next({\n            type: 'langChanged',\n            payload: getEventPayload(lang),\n        });\n        return this;\n    }\n    setAvailableLangs(langs) {\n        this.availableLangs = langs;\n    }\n    /**\n     * Gets the available languages.\n     *\n     * @returns\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n     * depending on how the available languages are set in your module.\n     */\n    getAvailableLangs() {\n        return this.availableLangs;\n    }\n    load(path, options = {}) {\n        const cached = this.cache.get(path);\n        if (cached) {\n            return cached;\n        }\n        let loadTranslation;\n        const isScope = this._isLangScoped(path);\n        let scope;\n        if (isScope) {\n            scope = getScopeFromLang(path);\n        }\n        const loadersOptions = {\n            path,\n            mainLoader: this.loader,\n            inlineLoader: options.inlineLoader,\n            data: isScope ? { scope: scope } : undefined,\n        };\n        if (this.useFallbackTranslation(path)) {\n            // if the path is scope the fallback should be `scope/fallbackLang`;\n            const fallback = isScope\n                ? `${scope}/${this.firstFallbackLang}`\n                : this.firstFallbackLang;\n            const loaders = getFallbacksLoaders({\n                ...loadersOptions,\n                fallbackPath: fallback,\n            });\n            loadTranslation = forkJoin(loaders);\n        }\n        else {\n            const loader = resolveLoader(loadersOptions);\n            loadTranslation = from(loader);\n        }\n        const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((translation) => {\n            if (Array.isArray(translation)) {\n                translation.forEach((t) => {\n                    this.handleSuccess(t.lang, t.translation);\n                    // Save the fallback in cache so we'll not create a redundant request\n                    if (t.lang !== path) {\n                        this.cache.set(t.lang, of({}));\n                    }\n                });\n                return;\n            }\n            this.handleSuccess(path, translation);\n        }), catchError((error) => {\n            if (!this.mergedConfig.prodMode) {\n                console.error(`Error while trying to load \"${path}\"`, error);\n            }\n            return this.handleFailure(path, options);\n        }), shareReplay(1));\n        this.cache.set(path, load$);\n        return load$;\n    }\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n    translate(key, params = {}, lang = this.getActiveLang()) {\n        if (!key)\n            return key;\n        const { scope, resolveLang } = this.resolveLangAndScope(lang);\n        if (Array.isArray(key)) {\n            return key.map((k) => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n        }\n        key = scope ? `${scope}.${key}` : key;\n        const translation = this.getTranslation(resolveLang);\n        const value = translation[key];\n        if (!value) {\n            return this._handleMissingKey(key, value, params);\n        }\n        return this.parser.transpile(value, params, translation);\n    }\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n     *\n     */\n    selectTranslate(key, params, lang, _isObject = false) {\n        let inlineLoader;\n        const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject\n            ? this.translateObject(key, params, lang)\n            : this.translate(key, params, lang)));\n        if (isNil(lang)) {\n            return this.langChanges$.pipe(switchMap((lang) => load(lang)));\n        }\n        if (isScopeObject(lang)) {\n            // it's a scope object.\n            const providerScope = lang;\n            lang = providerScope.scope;\n            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n        }\n        lang = lang;\n        if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n            return load(lang);\n        }\n        // it's a scope\n        const scope = lang;\n        return this.langChanges$.pipe(switchMap((lang) => load(`${scope}/${lang}`, { inlineLoader })));\n    }\n    /**\n     * Whether the scope with lang\n     *\n     * @example\n     *\n     * todos/en => true\n     * todos => false\n     */\n    isScopeWithLang(lang) {\n        return this.isLang(getLangFromScope(lang));\n    }\n    translateObject(key, params = {}, lang = this.getActiveLang()) {\n        if (isString(key) || Array.isArray(key)) {\n            const { resolveLang, scope } = this.resolveLangAndScope(lang);\n            if (Array.isArray(key)) {\n                return key.map((k) => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n            }\n            const translation = this.getTranslation(resolveLang);\n            key = scope ? `${scope}.${key}` : key;\n            const value = unflatten(this.getObjectByKey(translation, key));\n            /* If an empty object was returned we want to try and translate the key as a string and not an object */\n            return isEmpty(value)\n                ? this.translate(key, params, lang)\n                : this.parser.transpile(value, params, translation);\n        }\n        const translations = [];\n        for (const [_key, _params] of this.getEntries(key)) {\n            translations.push(this.translateObject(_key, _params, lang));\n        }\n        return translations;\n    }\n    selectTranslateObject(key, params, lang) {\n        if (isString(key) || Array.isArray(key)) {\n            return this.selectTranslate(key, params, lang, true);\n        }\n        const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((value) => {\n            const translations = [value];\n            for (const [_key, _params] of rest) {\n                translations.push(this.translateObject(_key, _params, lang));\n            }\n            return translations;\n        }));\n    }\n    getTranslation(langOrScope) {\n        if (langOrScope) {\n            if (this.isLang(langOrScope)) {\n                return this.translations.get(langOrScope) || {};\n            }\n            else {\n                // This is a scope, build the scope value from the translation object\n                const { scope, resolveLang } = this.resolveLangAndScope(langOrScope);\n                const translation = this.translations.get(resolveLang) || {};\n                return this.getObjectByKey(translation, scope);\n            }\n        }\n        return this.translations;\n    }\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe() - will return the current lang translation\n     * selectTranslation('es').subscribe()\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n     * selectTranslation('admin-page/es').subscribe()\n     */\n    selectTranslation(lang) {\n        let language$ = this.langChanges$;\n        if (lang) {\n            const scopeLangSpecified = getLangFromScope(lang) !== lang;\n            if (this.isLang(lang) || scopeLangSpecified) {\n                language$ = of(lang);\n            }\n            else {\n                language$ = this.langChanges$.pipe(map((currentLang) => `${lang}/${currentLang}`));\n            }\n        }\n        return language$.pipe(switchMap((language) => this.load(language).pipe(map(() => this.getTranslation(language)))));\n    }\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n    setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n        const defaults = { merge: true, emitChange: true };\n        const mergedOptions = { ...defaults, ...options };\n        const scope = getScopeFromLang(lang);\n        /**\n         * If this isn't a scope we use the whole translation as is\n         * otherwise we need to flat the scope and use it\n         */\n        let flattenScopeOrTranslation = translation;\n        // Merged the scoped language into the active language\n        if (scope) {\n            const key = this.getMappedScope(scope);\n            flattenScopeOrTranslation = flatten({ [key]: translation });\n        }\n        const currentLang = scope ? getLangFromScope(lang) : lang;\n        const mergedTranslation = {\n            ...(mergedOptions.merge && this.getTranslation(currentLang)),\n            ...flattenScopeOrTranslation,\n        };\n        const flattenTranslation = this.mergedConfig.flatten.aot\n            ? mergedTranslation\n            : flatten(mergedTranslation);\n        const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n        this.translations.set(currentLang, withHook);\n        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n    }\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n     */\n    setTranslationKey(key, value, \n    // Todo: Add the lang to the options in v3\n    lang = this.getActiveLang(), options = {}) {\n        const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n        const newValue = {\n            [key]: withHook,\n        };\n        this.setTranslation(newValue, lang, { ...options, merge: true });\n    }\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n    setFallbackLangForMissingTranslation({ fallbackLang, }) {\n        const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n        if (fallbackLang && this.useFallbackTranslation(lang)) {\n            this.firstFallbackLang = lang;\n        }\n    }\n    /**\n     * @internal\n     */\n    _handleMissingKey(key, value, params) {\n        if (this.config.missingHandler.allowEmpty && value === '') {\n            return '';\n        }\n        if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n            // We need to set it to true to prevent a loop\n            this.isResolvedMissingOnce = true;\n            const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n            this.isResolvedMissingOnce = false;\n            return fallbackValue;\n        }\n        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n    }\n    /**\n     * @internal\n     */\n    _isLangScoped(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) === -1;\n    }\n    /**\n     * Checks if a given string is one of the specified available languages.\n     * @returns\n     * True if the given string is an available language.\n     * False if the given string is not an available language.\n     */\n    isLang(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) !== -1;\n    }\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n    _loadDependencies(path, inlineLoader) {\n        const mainLang = getLangFromScope(path);\n        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));\n        }\n        return this.load(path, { inlineLoader });\n    }\n    /**\n     * @internal\n     */\n    _completeScopeWithLang(langOrScope) {\n        if (this._isLangScoped(langOrScope) &&\n            !this.isLang(getLangFromScope(langOrScope))) {\n            return `${langOrScope}/${this.getActiveLang()}`;\n        }\n        return langOrScope;\n    }\n    /**\n     * @internal\n     */\n    _setScopeAlias(scope, alias) {\n        if (!this.mergedConfig.scopeMapping) {\n            this.mergedConfig.scopeMapping = {};\n        }\n        this.mergedConfig.scopeMapping[scope] = alias;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n        // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n        // and destroyed per each HTTP request, but any service is not getting GC'd.\n        this.cache.clear();\n    }\n    isLoadedTranslation(lang) {\n        return size(this.getTranslation(lang));\n    }\n    getAvailableLangsIds() {\n        const first = this.getAvailableLangs()[0];\n        if (isString(first)) {\n            return this.getAvailableLangs();\n        }\n        return this.getAvailableLangs().map((l) => l.id);\n    }\n    getMissingHandlerData() {\n        return {\n            ...this.config,\n            activeLang: this.getActiveLang(),\n            availableLangs: this.availableLangs,\n            defaultLang: this.defaultLang,\n        };\n    }\n    /**\n     * Use a fallback translation set for missing keys of the primary language\n     * This is unrelated to the fallback language (which changes the active language)\n     */\n    useFallbackTranslation(lang) {\n        return (this.config.missingHandler.useFallbackTranslation &&\n            lang !== this.firstFallbackLang);\n    }\n    handleSuccess(lang, translation) {\n        this.setTranslation(translation, lang, { emitChange: false });\n        this.events.next({\n            wasFailure: !!this.failedLangs.size,\n            type: 'translationLoadSuccess',\n            payload: getEventPayload(lang),\n        });\n        this.failedLangs.forEach((l) => this.cache.delete(l));\n        this.failedLangs.clear();\n    }\n    handleFailure(lang, loadOptions) {\n        // When starting to load a first choice language, initialize\n        // the failed counter and resolve the fallback langs.\n        if (isNil(loadOptions.failedCounter)) {\n            loadOptions.failedCounter = 0;\n            if (!loadOptions.fallbackLangs) {\n                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n            }\n        }\n        const splitted = lang.split('/');\n        const fallbacks = loadOptions.fallbackLangs;\n        const nextLang = fallbacks[loadOptions.failedCounter];\n        this.failedLangs.add(lang);\n        // This handles the case where a loaded fallback language is requested again\n        if (this.cache.has(nextLang)) {\n            this.handleSuccess(nextLang, this.getTranslation(nextLang));\n            return EMPTY;\n        }\n        const isFallbackLang = nextLang === splitted[splitted.length - 1];\n        if (!nextLang || isFallbackLang) {\n            let msg = `Unable to load translation and all the fallback languages`;\n            if (splitted.length > 1) {\n                msg += `, did you misspelled the scope name?`;\n            }\n            throw new Error(msg);\n        }\n        let resolveLang = nextLang;\n        // if it's scoped lang\n        if (splitted.length > 1) {\n            // We need to resolve it to:\n            // todos/langNotExists => todos/nextLang\n            splitted[splitted.length - 1] = nextLang;\n            resolveLang = splitted.join('/');\n        }\n        loadOptions.failedCounter++;\n        this.events.next({\n            type: 'translationLoadFailure',\n            payload: getEventPayload(lang),\n        });\n        return this.load(resolveLang, loadOptions);\n    }\n    getMappedScope(scope) {\n        const { scopeMapping = {} } = this.config;\n        return scopeMapping[scope] || toCamelCase(scope);\n    }\n    /**\n     * If lang is scope we need to check the following cases:\n     * todos/es => in this case we should take `es` as lang\n     * todos => in this case we should set the active lang as lang\n     */\n    resolveLangAndScope(lang) {\n        let resolveLang = lang;\n        let scope;\n        if (this._isLangScoped(lang)) {\n            // en for example\n            const langFromScope = getLangFromScope(lang);\n            // en is lang\n            const hasLang = this.isLang(langFromScope);\n            // take en\n            resolveLang = hasLang ? langFromScope : this.getActiveLang();\n            // find the scope\n            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n        }\n        return { scope, resolveLang };\n    }\n    getObjectByKey(translation, key) {\n        const result = {};\n        const prefix = `${key}.`;\n        for (const currentKey in translation) {\n            if (currentKey.startsWith(prefix)) {\n                result[currentKey.replace(prefix, '')] = translation[currentKey];\n            }\n        }\n        return result;\n    }\n    getEntries(key) {\n        return key instanceof Map ? key.entries() : Object.entries(key);\n    }\n}\nTranslocoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoService, deps: [{ token: TRANSLOCO_LOADER, optional: true }, { token: TRANSLOCO_TRANSPILER }, { token: TRANSLOCO_MISSING_HANDLER }, { token: TRANSLOCO_INTERCEPTOR }, { token: TRANSLOCO_CONFIG }, { token: TRANSLOCO_FALLBACK_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });\nTranslocoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoService, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LOADER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TRANSPILER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_MISSING_HANDLER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_INTERCEPTOR]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_FALLBACK_STRATEGY]\n                }] }]; } });\n\nclass TranslocoLoaderComponent {\n}\nTranslocoLoaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoLoaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nTranslocoLoaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.10\", type: TranslocoLoaderComponent, selector: \"ng-component\", inputs: { html: \"html\" }, ngImport: i0, template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `, isInline: true });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoLoaderComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `,\n                }]\n        }], propDecorators: { html: [{\n                type: Input\n            }] } });\n\nclass TemplateHandler {\n    constructor(view, vcr) {\n        this.view = view;\n        this.vcr = vcr;\n        this.injector = this.vcr.injector;\n    }\n    attachView() {\n        if (this.view instanceof TemplateRef) {\n            this.vcr.createEmbeddedView(this.view);\n        }\n        else if (isString(this.view)) {\n            const componentRef = this.createComponent(TranslocoLoaderComponent);\n            componentRef.instance.html = this.view;\n            componentRef.hostView.detectChanges();\n        }\n        else {\n            this.createComponent(this.view);\n        }\n    }\n    detachView() {\n        this.vcr.clear();\n    }\n    createComponent(cmp) {\n        const cfr = this.injector.get(ComponentFactoryResolver);\n        const factory = cfr.resolveComponentFactory(cmp);\n        return this.vcr.createComponent(factory);\n    }\n}\n\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\n\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\n\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nclass LangResolver {\n    constructor() {\n        this.initialized = false;\n    }\n    // inline => provider => active\n    resolve({ inline, provider, active }) {\n        let lang = active;\n        /**\n         * When the user changes the lang we need to update\n         * the view. Otherwise, the lang will remain the inline/provided lang\n         */\n        if (this.initialized) {\n            lang = active;\n            return lang;\n        }\n        if (provider) {\n            const [, extracted] = getPipeValue(provider, 'static');\n            lang = extracted;\n        }\n        if (inline) {\n            const [, extracted] = getPipeValue(inline, 'static');\n            lang = extracted;\n        }\n        this.initialized = true;\n        return lang;\n    }\n    /**\n     *\n     * Resolve the lang\n     *\n     * @example\n     *\n     * resolveLangBasedOnScope('todos/en') => en\n     * resolveLangBasedOnScope('en') => en\n     *\n     */\n    resolveLangBasedOnScope(lang) {\n        const scope = getScopeFromLang(lang);\n        return scope ? getLangFromScope(lang) : lang;\n    }\n    /**\n     *\n     * Resolve the lang path for loading\n     *\n     * @example\n     *\n     * resolveLangPath('todos', 'en') => todos/en\n     * resolveLangPath('en') => en\n     *\n     */\n    resolveLangPath(lang, scope) {\n        return scope ? `${scope}/${lang}` : lang;\n    }\n}\n\nclass ScopeResolver {\n    constructor(translocoService) {\n        this.translocoService = translocoService;\n    }\n    // inline => provider\n    resolve({ inline, provider } = {\n        inline: undefined,\n        provider: undefined,\n    }) {\n        if (inline) {\n            return inline;\n        }\n        if (provider) {\n            if (isScopeObject(provider)) {\n                const { scope, alias = toCamelCase(scope) } = provider;\n                this.translocoService._setScopeAlias(scope, alias);\n                return scope;\n            }\n            return provider;\n        }\n        return undefined;\n    }\n}\n\nclass TranslocoDirective {\n    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {\n        this.translocoService = translocoService;\n        this.tpl = tpl;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.providedLoadingTpl = providedLoadingTpl;\n        this.vcr = vcr;\n        this.cdr = cdr;\n        this.host = host;\n        this.renderer = renderer;\n        this.subscription = null;\n        this.translationMemo = {};\n        this.params = {};\n        // Whether we already rendered the view once\n        this.initialized = false;\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n        this.strategy = this.tpl === null ? 'attribute' : 'structural';\n    }\n    static ngTemplateContextGuard(dir, ctx) {\n        return true;\n    }\n    ngOnInit() {\n        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: this.inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => {\n            this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n            this.strategy === 'attribute'\n                ? this.attributeStrategy()\n                : this.structuralStrategy(this.currentLang, this.inlineRead);\n            this.cdr.markForCheck();\n            this.initialized = true;\n        });\n        const loadingTpl = this.getLoadingTpl();\n        if (!this.initialized && loadingTpl) {\n            this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n            this.loaderTplHandler.attachView();\n        }\n    }\n    ngOnChanges(changes) {\n        // We need to support dynamic keys/params, so if this is not the first change CD cycle\n        // we need to run the function again in order to update the value\n        if (this.strategy === 'attribute') {\n            const notInit = Object.keys(changes).some((v) => !changes[v].firstChange);\n            notInit && this.attributeStrategy();\n        }\n    }\n    attributeStrategy() {\n        this.detachLoader();\n        this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));\n    }\n    structuralStrategy(lang, read) {\n        this.translationMemo = {};\n        if (this.view) {\n            // when the lang changes we need to change the reference so Angular will update the view\n            this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n            this.view.context['currentLang'] = this.currentLang;\n        }\n        else {\n            this.detachLoader();\n            this.view = this.vcr.createEmbeddedView(this.tpl, {\n                $implicit: this.getTranslateFn(lang, read),\n                currentLang: this.currentLang,\n            });\n        }\n    }\n    getTranslateFn(lang, read) {\n        return (key, params) => {\n            const withRead = read ? `${read}.${key}` : key;\n            const withParams = params\n                ? `${withRead}${JSON.stringify(params)}`\n                : withRead;\n            if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n                return this.translationMemo[withParams].value;\n            }\n            this.translationMemo[withParams] = {\n                params,\n                value: this.translocoService.translate(withRead, params, lang),\n            };\n            return this.translationMemo[withParams].value;\n        };\n    }\n    getLoadingTpl() {\n        return this.inlineTpl || this.providedLoadingTpl;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n    }\n    detachLoader() {\n        this.loaderTplHandler?.detachView();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: this.inlineScope,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n}\nTranslocoDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoDirective, deps: [{ token: TranslocoService }, { token: i0.TemplateRef, optional: true }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: TRANSLOCO_LOADING_TEMPLATE, optional: true }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });\nTranslocoDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.10\", type: TranslocoDirective, selector: \"[transloco]\", inputs: { key: [\"transloco\", \"key\"], params: [\"translocoParams\", \"params\"], inlineScope: [\"translocoScope\", \"inlineScope\"], inlineRead: [\"translocoRead\", \"inlineRead\"], inlineLang: [\"translocoLang\", \"inlineLang\"], inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"] }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[transloco]',\n                }]\n        }], ctorParameters: function () { return [{ type: TranslocoService }, { type: i0.TemplateRef, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_SCOPE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LANG]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LOADING_TEMPLATE]\n                }] }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { key: [{\n                type: Input,\n                args: ['transloco']\n            }], params: [{\n                type: Input,\n                args: ['translocoParams']\n            }], inlineScope: [{\n                type: Input,\n                args: ['translocoScope']\n            }], inlineRead: [{\n                type: Input,\n                args: ['translocoRead']\n            }], inlineLang: [{\n                type: Input,\n                args: ['translocoLang']\n            }], inlineTpl: [{\n                type: Input,\n                args: ['translocoLoadingTpl']\n            }] } });\n\nclass TranslocoPipe {\n    constructor(translocoService, providerScope, providerLang, cdr) {\n        this.translocoService = translocoService;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.cdr = cdr;\n        this.subscription = null;\n        this.lastValue = '';\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n    }\n    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n    transform(key, params, inlineLang) {\n        if (!key) {\n            return key;\n        }\n        const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n        if (keyName === this.lastKey) {\n            return this.lastValue;\n        }\n        this.lastKey = keyName;\n        this.subscription?.unsubscribe();\n        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => this.updateValue(key, params));\n        return this.lastValue;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n    }\n    updateValue(key, params) {\n        const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.lastValue = this.translocoService.translate(key, params, lang);\n        this.cdr.markForCheck();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: undefined,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n}\nTranslocoPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoPipe, deps: [{ token: TranslocoService }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });\nTranslocoPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoPipe, name: \"transloco\", pure: false });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'transloco',\n                    pure: false,\n                }]\n        }], ctorParameters: function () { return [{ type: TranslocoService }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_SCOPE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LANG]\n                }] }, { type: i0.ChangeDetectorRef }]; } });\n\nconst defaultProviders = [\n    {\n        provide: TRANSLOCO_TRANSPILER,\n        useClass: DefaultTranspiler,\n        deps: [TRANSLOCO_CONFIG],\n    },\n    {\n        provide: TRANSLOCO_MISSING_HANDLER,\n        useClass: DefaultHandler,\n    },\n    {\n        provide: TRANSLOCO_INTERCEPTOR,\n        useClass: DefaultInterceptor,\n    },\n    {\n        provide: TRANSLOCO_FALLBACK_STRATEGY,\n        useClass: DefaultFallbackStrategy,\n        deps: [TRANSLOCO_CONFIG],\n    },\n];\nclass TranslocoModule {\n}\nTranslocoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nTranslocoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent], exports: [TranslocoDirective, TranslocoPipe] });\nTranslocoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, providers: [defaultProviders] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n                    providers: [defaultProviders],\n                    exports: [TranslocoDirective, TranslocoPipe]\n                }]\n        }] });\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nclass TestingLoader {\n    constructor(langs) {\n        this.langs = langs;\n    }\n    getTranslation(lang) {\n        return of(this.langs[lang]);\n    }\n}\nTestingLoader.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TestingLoader, deps: [{ token: TRANSLOCO_TEST_LANGS }], target: i0.ɵɵFactoryTarget.Injectable });\nTestingLoader.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TestingLoader });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TestingLoader, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TEST_LANGS]\n                }] }]; } });\nfunction initTranslocoService(service, langs = {}, options) {\n    const preloadAllLangs = () => options.preloadLangs\n        ? Promise.all(Object.keys(langs).map((lang) => service.load(lang).toPromise()))\n        : Promise.resolve();\n    return preloadAllLangs;\n}\nclass TranslocoTestingModule {\n    static forRoot(options) {\n        return {\n            ngModule: TranslocoTestingModule,\n            providers: [\n                {\n                    provide: TRANSLOCO_TEST_LANGS,\n                    useValue: options.langs,\n                },\n                {\n                    provide: TRANSLOCO_TEST_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: APP_INITIALIZER,\n                    useFactory: initTranslocoService,\n                    deps: [\n                        TranslocoService,\n                        TRANSLOCO_TEST_LANGS,\n                        TRANSLOCO_TEST_OPTIONS,\n                    ],\n                    multi: true,\n                },\n                {\n                    provide: TRANSLOCO_LOADER,\n                    useClass: TestingLoader,\n                },\n                defaultProviders,\n                {\n                    provide: TRANSLOCO_CONFIG,\n                    useValue: translocoConfig({\n                        prodMode: true,\n                        missingHandler: { logMissingKey: false },\n                        ...options.translocoConfig,\n                    }),\n                },\n            ],\n        };\n    }\n}\nTranslocoTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nTranslocoTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, exports: [TranslocoModule] });\nTranslocoTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, imports: [TranslocoModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [TranslocoModule],\n                }]\n        }] });\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nfunction getBrowserLang() {\n    let browserLang = getBrowserCultureLang();\n    if (!browserLang || !isBrowser()) {\n        return undefined;\n    }\n    if (browserLang.indexOf('-') !== -1) {\n        browserLang = browserLang.split('-')[0];\n    }\n    if (browserLang.indexOf('_') !== -1) {\n        browserLang = browserLang.split('_')[0];\n    }\n    return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nfunction getBrowserCultureLang() {\n    if (!isBrowser()) {\n        return '';\n    }\n    const navigator = window.navigator;\n    let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n    browserCultureLang =\n        browserCultureLang ||\n            navigator.language ||\n            navigator.browserLanguage ||\n            navigator.userLanguage;\n    return browserCultureLang;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten };\n"]},"metadata":{},"sourceType":"module"}